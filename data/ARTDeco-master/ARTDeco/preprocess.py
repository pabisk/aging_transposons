'''
Module that contains functions for running preprocessing operations.
'''
import pandas as pd
import subprocess
import os
import numpy as np
from multiprocessing import Pool

'''
Define a function that can parse out feature information from a gene.
'''
def parse_features(gene):

    #Get feature information.
    features = gene[6]

    #Parse into dictionary.
    features = features.split(';')
    features = [x.replace('"','').split() for x in features]

    feature_dict = {}
    for feature in features:
        if len(feature) == 2:
            feature_dict[feature[0]] = feature[1]

    return feature_dict

'''
Define a function that indicates whether one set of coordinates is inside another.
'''
def is_inside(interval1,interval2):

    if interval1[0] >= interval2[0] and interval1[1] <= interval2[1]:
        return True
    else:
        return False

'''
Define a function that indicates whether a gene is inside another gene on the same chromosome and strand.
'''
def is_inside_gene(gene,gb):
    for gene1 in gb.get_group((gene[1],gene[2])).values:

        if gene[0] == gene1[0]:
            continue

        if is_inside(gene[-2:],gene1[-2:]):
            return True

    return False

'''
Define a function that can parse a BED file of annotations generated by BEDOPS.
'''
def parse_gene_bed(bed_file):

    #Load into pandas dataframe.
    genes = pd.read_csv(bed_file,sep='\t',header=None,
                        names=['Chrom','Start','End','Gene ID','Score','Strand','Source','Feature','Score1',
                               'FeatureInfo'])
    genes = genes[['Gene ID','Feature','Chrom','Start','End','Strand','FeatureInfo']]

    #Limit to genes on non-mitochondrial chromosomes.
    genes = genes[genes.Chrom != 'chrM']

    #For each gene, parse out the feature info to get the transcript ID. Only keep entries with a transcript ID. Include
    #gene type information if available.
    transcripts = []
    for gene in genes.values:

        features = parse_features(gene)

        if 'transcript_id' in features.keys():

            transcript_dict = {'Gene ID':gene[0],'Feature':gene[1],'Chrom':gene[2],'Start':gene[3],'End':gene[4],
                               'Strand':gene[5],'Transcript ID':features['transcript_id']}

            if 'gene_type' in features.keys():
                transcript_dict['Gene Type'] = features['gene_type']

            transcripts.append(transcript_dict)

    genes = pd.DataFrame(transcripts)

    if 'Gene Type' in genes.columns:
        gene_types = genes[['Gene ID','Gene Type']].drop_duplicates()
    else:
        gene_types = pd.DataFrame()

    genes = genes[['Gene ID','Transcript ID','Feature','Chrom','Start','End','Strand']]

    #If a transcript is a feature, limit features to that. Otherwise, get the transcript coordinates.
    if 'transcript' in genes.Feature.unique():
        genes = genes[genes.Feature == 'transcript']
    else:

        #Get minimum start and maximum stop.
        min_start = genes[['Gene ID','Transcript ID','Start']].groupby('Transcript ID').min().reset_index()
        max_stop = genes[['Gene ID','Transcript ID','End']].groupby('Transcript ID').max().reset_index()

        #Join coordinates and then join with other gene information.
        max_min = pd.merge(min_start,max_stop,on=['Transcript ID','Gene ID'])
        genes = pd.merge(genes[['Gene ID','Transcript ID','Feature','Chrom','Strand']],max_min,
                         on=['Gene ID','Transcript ID'])

    del genes['Feature']

    #Get gene-to-transcript map.
    gene_to_transcript = genes[['Gene ID','Transcript ID']].drop_duplicates()

    #Condense annotation to minimum start and maximum stop for each gene.
    del genes['Transcript ID']

    min_start = genes[['Gene ID','Start']].groupby('Gene ID').min().reset_index()
    max_stop = genes[['Gene ID','End']].groupby('Gene ID').max().reset_index()
    max_min = pd.merge(min_start,max_stop,on='Gene ID')

    #Filter for genes only annotated on a single chromosome.
    genes = genes[['Gene ID','Chrom','Strand']]
    unique_counts = genes.groupby('Gene ID').nunique()
    unique_counts = unique_counts[unique_counts.Chrom == 1]
    genes = genes[genes['Gene ID'].isin(unique_counts.index)]
    genes = genes.drop_duplicates()
    genes = pd.merge(genes,max_min,on='Gene ID')

    #Remove genes that are located within other genes.
    gb = genes.groupby(['Chrom','Strand'])
    to_keep = []
    for gene in genes.values:
        if not is_inside_gene(gene,gb):
            to_keep.append(gene[0])
    genes = genes[genes['Gene ID'].isin(to_keep)].copy()

    #Format genes for output.
    genes['Score'] = 0
    genes = genes[['Chrom','Start','End','Gene ID','Score','Strand']]
    genes.columns = ['Chrom','Start','End','Name','Score','Strand']

    return genes,gene_types,gene_to_transcript

'''
Define a function that can do the conversion of a GTF file into a condensed genes dataframe.
'''
def parse_gtf(gtf_file,home_dir):

    #Run command to convert GTF to bed.
    print('Convert GTF to BED...')
    gene_full_bed = os.path.join(home_dir,'preprocess_files','genes.full.bed')

    f = open(gene_full_bed,'w')
    subprocess.call(f"gtf2bed < {gtf_file}",shell=True,stdout=f)
    f.close()

    #Generate condensed genes and gene-to-transcript mapping.
    print('Generating condensed genes bed...')
    genes,gene_types,gene_to_transcript = parse_gene_bed(gene_full_bed)

    #Output condensed genes BED file and gene-to-transcript mapping file.
    genes.to_csv(os.path.join(home_dir,'preprocess_files','genes_condensed.bed'),sep='\t',header=False,index=False)
    gene_types.to_csv(os.path.join(home_dir,'preprocess_files','gene_types.txt'),sep='\t',index=False)
    gene_to_transcript.to_csv(os.path.join(home_dir,'preprocess_files','gene_to_transcript.txt'),index=False,sep='\t')

'''
Define a function that can format intergenic dataframes.
'''
def format_read_in_df(df,min_len,chrom_lengths):

    df = df.dropna()
    if 'Length' in df.columns:
        df = df[df.Length > min_len].copy()
        del df['Length']
    df = df[df.Start > 0].copy()
    df['Max Len'] = df.apply(lambda x: x[4] < chrom_lengths[x[1]],axis=1)
    df = df[df['Max Len'] == True].copy()
    del df['Max Len']
    df['Stop'] = df['Stop'].astype(int)
    df = df.sort_values(['Chrom','Start','Stop'])
    df = df.reset_index(drop=True)

    return df

'''
Define a function that can create read in and read through dataframes for stranded data.
'''
def create_stranded_read_in_df(df,chrom_lengths,max_len=15000,min_len=100,upstream_dist=1000):

    #Separate the data into strands.
    pos_strand = df[df.Strand == '+'].copy()
    neg_strand = df[df.Strand == '-'].copy()

    #Get readthrough and readin tracks for positive strand.
    pos_strand['Upstream Stop'] = pos_strand.Start-upstream_dist
    pos_strand_vals = pos_strand.values
    upstream_start = []

    for i in range(len(pos_strand_vals)):

        row = pos_strand_vals[i]

        #Get the read in.
        #If the gene is not the first gene, find the read-in region.
        if i > 0:

            prev_row = pos_strand_vals[i-1]

            #If the upstream gene and the current gene are on the same chromosome, find the read-in region.
            if row[1] == prev_row[1]:

                dist = row[5]-prev_row[4]
                dist = dist/3
                dist = min(dist,max_len)

                #If the distance is longer than the minimum length, record the upstream start.
                if dist > min_len:
                    upstream_start.append(row[5]-dist)
                else:
                    upstream_start.append(np.nan)
            else:
                upstream_start.append(np.nan)

        else:
            upstream_start.append(np.nan)

    pos_strand['Upstream Start'] = upstream_start
    pos_strand = pos_strand.dropna()
    pos_strand['Upstream Start'] = pos_strand['Upstream Start'].astype(int)

    #Get read-in tracks for negative strand.
    neg_strand['Upstream Start'] = neg_strand.Stop+upstream_dist

    neg_strand_vals = neg_strand.values
    upstream_stop = []
    for i in range(len(neg_strand_vals)):

        row = neg_strand_vals[i]

        #Get the read in.
        #If the upstream gene and the current gene are on the same chromosome, find the read-in region.
        if i+1 < len(neg_strand_vals):

            next_row = neg_strand_vals[i+1]

            # If the upstream gene and the current gene are on the same chromosome, find the read-in region.
            if row[1] == next_row[1]:

                dist = next_row[3]-row[5]
                dist = dist/3
                dist = min(dist,max_len)

                # If the distance is longer than the minimum length, record the upstream start.
                if dist > min_len:
                    upstream_stop.append(row[5]+dist)
                else:
                    upstream_stop.append(np.nan)

            else:
                upstream_stop.append(np.nan)
        else:
            upstream_stop.append(np.nan)

    neg_strand['Upstream Stop'] = upstream_stop
    neg_strand = neg_strand.dropna()
    neg_strand['Upstream Stop'] = neg_strand['Upstream Stop'].astype(int)

    #Format and combine the positive and negative strand dataframes.
    pos_strand = pos_strand[['Name','Chrom','Strand','Upstream Start','Upstream Stop']]
    neg_strand = neg_strand[['Name','Chrom','Strand','Upstream Start','Upstream Stop']]
    read_in = pos_strand.append(neg_strand)
    read_in.columns = ['Name','Chrom','Strand','Start','Stop']
    read_in = read_in[read_in.Start < read_in.Stop]
    read_in = read_in.sort_values(['Chrom','Start'])
    read_in = format_read_in_df(read_in,min_len,chrom_lengths)

    return read_in

'''
Define a function that can create read in and read through dataframes for unstranded data.
'''
def create_unstranded_read_in_df(df,chrom_lengths,max_len=15000,min_len=100,upstream_dist=1000):

    #Set upstream distance.
    genes_df = df.copy()
    genes_df['Upstream Start'] = 0

    #Positive strand.
    pos_strand = genes_df[genes_df.Strand == '+'].index
    genes_df.loc[pos_strand,'Upstream Start'] = genes_df.Start-upstream_dist

    #Negative strand.
    neg_strand = genes_df[genes_df.Strand == '-'].index
    genes_df.loc[neg_strand,'Upstream Start'] = genes_df.Stop+upstream_dist

    #Get read-in lengths.
    gene_vals = genes_df.values

    read_in_length = []
    for i in range(len(gene_vals)):

        row = gene_vals[i]

        #Get previous and next row.
        if i > 0:
            prev_row = gene_vals[i-1]
        else:
            prev_row = []
        if i < len(gene_vals)-1:
            next_row = gene_vals[i+1]
        else:
            next_row = []

        #Positive strand case.
        if row[2] == '+':

            #Get the read-in.
            if len(prev_row) == 0 or row[1] != prev_row[1] or row[2] != prev_row[2]:
                dist = np.nan
            else:
                dist = row[5]-prev_row[4]
                dist = int(dist/3)

            read_in_length.append(min(dist,max_len))

        #Negative strand case.
        if row[2] == '-':

            # Get the read-in.
            if len(next_row) == 0 or row[1] != next_row[1] or row[2] != next_row[2]:
                dist = np.nan
            else:
                dist = next_row[3]-row[5]
                dist = int(dist/3)

            read_in_length.append(min(dist,max_len))

    genes_df['Read In Length'] = read_in_length

    #Set Upstream stop.
    #Positive strand.
    pos_strand_df = genes_df.loc[pos_strand]
    pos_strand_df['Upstream Stop'] = pos_strand_df['Upstream Start']
    pos_strand_df['Upstream Start'] = pos_strand_df['Upstream Start']-pos_strand_df['Read In Length']

    #Negative strand.
    neg_strand_df = genes_df.loc[neg_strand]
    neg_strand_df['Upstream Stop'] = neg_strand_df['Upstream Start']+neg_strand_df['Read In Length']

    #Combine strands.
    genes_df = pos_strand_df.append(neg_strand_df)
    genes_df = genes_df.sort_values(['Chrom','Start','Stop'])

    #Format read-in dataframe.
    read_in = genes_df[['Name','Chrom','Strand','Upstream Start','Upstream Stop','Read In Length']].copy()
    read_in.columns = ['Name','Chrom','Strand','Start','Stop','Length']
    read_in = read_in[read_in.Start < read_in.Stop]
    read_in = format_read_in_df(read_in,min_len,chrom_lengths)

    return read_in

'''
Define a function that can create a dataframe with downstream regions for stranded data. 
'''
def create_stranded_downstream_df(df,chrom_lengths,max_len=15000,min_len=100,downstream_dist=5000):

    #Separate strands.
    pos_strand = df[df.Strand == '+'].copy()
    neg_strand = df[df.Strand == '-'].copy()

    #Get the intergenic regions downstream of each gene.
    #Positive strand case.
    pos_strand['Downstream Start'] = pos_strand.Stop+downstream_dist
    pos_strand_vals = pos_strand.values
    downstream_stop = []

    for i in range(len(pos_strand_vals)):

        row = pos_strand_vals[i]

        #Get the downstream region.
        if i < len(pos_strand_vals)-1:

            next_row = pos_strand_vals[i+1]

            #If the downstream gene is not on the same chromosome, set the downstream region as the maximum length.
            if row[1] == next_row[1]:

                dist = next_row[3]-row[5]
                dist = dist/3
                dist = min(dist,max_len)

                # If the distance is longer than the minimum length, record the downstream stop.
                if dist > min_len:
                    downstream_stop.append(row[5]+dist)
                else:
                    downstream_stop.append(np.nan)

            else:
                downstream_stop.append(min(row[5]+max_len,chrom_lengths[row[1]]))

        else:
            downstream_stop.append(min(row[5]+max_len,chrom_lengths[row[1]]))

    pos_strand['Downstream Stop'] = downstream_stop
    pos_strand = pos_strand.dropna()
    pos_strand['Downstream Stop'] = pos_strand['Downstream Stop'].astype(int)

    #Negative strand case.
    neg_strand['Downstream Stop'] = neg_strand.Start-downstream_dist
    neg_strand_vals = neg_strand.values
    downstream_start = []

    for i in range(len(neg_strand_vals)):

        row = neg_strand_vals[i]

        #Get the downstream region.
        if i > 0:

            prev_row = neg_strand_vals[i-1]

            #If the downstream gene is not on the same chromosome, set the downstream region as the maximum length.
            if row[1] == prev_row[1]:

                dist = row[5]-prev_row[4]
                dist = dist/3
                dist = min(dist,max_len)

                #If the distance is longer than the minimum length, record the downstream stop.
                if dist > min_len:
                    downstream_start.append(row[5]-dist)
                else:
                    downstream_start.append(np.nan)

            else:
                downstream_start.append(max(row[5]-max_len,1))

        else:
            downstream_start.append(max(row[5]-max_len,1))

    neg_strand['Downstream Start'] = downstream_start
    neg_strand = neg_strand.dropna()
    neg_strand['Downstream Start'] = neg_strand['Downstream Start'].astype(int)

    #Format and combine the positive and negative strand dataframes.
    pos_strand = pos_strand[['Name','Chrom','Strand','Downstream Start','Downstream Stop']]
    neg_strand = neg_strand[['Name','Chrom','Strand','Downstream Start','Downstream Stop']]
    downstream = pos_strand.append(neg_strand)
    downstream.columns = ['Name','Chrom','Strand','Start','Stop']
    downstream = downstream[downstream.Start < downstream.Stop]
    downstream = downstream.sort_values(['Chrom','Start'])
    downstream = downstream.reset_index(drop=True)

    return downstream

'''
Define a function that can create a dataframe with downstream regions for unstranded data. 
'''
def create_unstranded_downstream_df(df,chrom_lengths,max_len=15000,min_len=100,downstream_dist=5000):

    #Set downstream distance.
    genes_df = df.copy()
    genes_df['Downstream Start'] = np.nan
    genes_df['Downstream Stop'] = np.nan

    #Positive strand.
    pos_strand = genes_df[genes_df.Strand == '+'].index
    genes_df.loc[pos_strand,'Downstream Start'] = genes_df.Stop+downstream_dist

    #Negative strand.
    neg_strand = genes_df[genes_df.Strand == '-'].index
    genes_df.loc[neg_strand,'Downstream Stop'] = genes_df.Start-downstream_dist

    #Get read-in lengths.
    gene_vals = genes_df.values
    downstream_start = []
    downstream_stop = []
    for i in range(len(gene_vals)):

        row = gene_vals[i]

        #Get previous and next row.
        if i > 0:
            prev_row = gene_vals[i-1]
        else:
            prev_row = []
        if i < len(gene_vals)-1:
            next_row = gene_vals[i+1]
        else:
            next_row = []

        #Positive strand case.
        if row[2] == '+':

            #If there is no downstream gene or the downstream gene is on another chromosome, assign the distance as the
            #maximum.
            if len(next_row) == 0 or row[1] != next_row[1]:
                downstream_stop.append(min(row[5]+max_len,chrom_lengths[row[1]]))

            #If the downstream gene is on the opposite strand, assign the distance as nan.
            elif row[2] != next_row[2]:
                downstream_stop.append(np.nan)

            #Otherwise, assign the distance as usual.
            else:
                dist = next_row[3]-row[5]
                dist = dist/3
                dist = min(dist,max_len)

                #If the distance is longer than the minimum length, record the downstream stop.
                if dist > min_len:
                    downstream_stop.append(row[5]+dist)
                else:
                    downstream_stop.append(np.nan)

        #Negative strand case.
        if row[2] == '-':

            #If there is no downstream gene or the downstream gene is on another chromosome, assign the distance as the
            #maximum.
            if len(prev_row) == 0 or row[1] != prev_row[1]:
                downstream_start.append(max(row[6]-max_len,1))

            #If the downstream gene is on the opposite strand, assign the distance as nan.
            elif row[2] != prev_row[2]:
                downstream_start.append(np.nan)

            #Otherwise assign the distance as usual.
            else:
                dist = row[6]-prev_row[4]
                dist = dist/3
                dist = min(dist,max_len)

                #If the distance is longer than the minimum length, record the downstream stop.
                if dist > min_len:
                    downstream_start.append(row[6]-dist)
                else:
                    downstream_start.append(np.nan)

    #Set the downstream start and stop.
    #Positive strand.
    pos_strand = genes_df[genes_df.Strand == '+'].index
    genes_df.loc[pos_strand,'Downstream Stop'] = downstream_stop

    #Negative strand.
    neg_strand = genes_df[genes_df.Strand == '-'].index
    genes_df.loc[neg_strand,'Downstream Start'] = downstream_start

    #Format output.
    genes_df = genes_df.dropna()
    genes_df = genes_df.reset_index(drop=True)
    genes_df['Downstream Start'] = genes_df['Downstream Start'].astype(int)
    genes_df['Downstream Stop'] = genes_df['Downstream Stop'].astype(int)
    genes_df = genes_df[['Name','Chrom','Strand','Downstream Start','Downstream Stop']]
    genes_df.columns = ['Name','Chrom','Strand','Start','Stop']
    genes_df = genes_df[genes_df.Start < genes_df.Stop].copy()

    return genes_df

'''
Define a function that can create a Homer tag directory.
'''
def make_tag_directory(args):

    bam_file,tag_directory,flip,pe,stranded,single = args

    #Format optional Homer commands.
    cmds = []
    if flip:
        cmds.append('-flip')
    if pe and stranded:
        cmds.append('-sspe')
    if single:
        cmds.append('-single')

    #Call Homer.
    p = subprocess.Popen(['makeTagDirectory',tag_directory,bam_file]+cmds,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    out,err = p.communicate()

'''
Define a function that can create a batch of Homer tag directories. Currently configured assuming all have the same
format.
'''
def make_multi_tag_dirs(bam_files,out_dir,flip,pe,stranded,single,cpu):

    cmds = [(bam_file,os.path.join(out_dir,bam_file.split('/')[-1][:-4]),flip,pe,stranded,single) for bam_file in bam_files]
    pool = Pool(processes=cpu)
    pool.map(make_tag_directory,cmds)
    pool.close()
